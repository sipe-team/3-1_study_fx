# 함수형 프로그래밍: 불변성과 구조적 설계의 힘

함수형 프로그래밍에서는 코드의 명확성과 유지 보수를 쉽게 하기 위해 몇 가지 중요한 원칙들이 있습니다. 여기서는 특히 불변성 유지와 암묵적 입력, 출력을 명시적으로 바꾸는 방법에 대해 살펴보겠습니다. 이를 통해 설계가 엉킨 부분을 푸는 과정을 이해하고, 함수의 단일 책임 원칙을 준수하는 방법을 배울 수 있습니다. Haskell과 Kotlin을 활용하여 구체적인 예시를 들어 설명해 보겠습니다.

## 불변성을 위한 설계: 암묵적 입력과 출력 제거

함수형 프로그래밍에서는 코드의 복잡도를 줄이기 위해 암묵적 입력과 출력을 함수의 인자와 리턴 값으로 바꾸는 것이 좋습니다. 이렇게 하면 함수가 특정한 일만 하도록 제한하여 코드를 명확하게 만들 수 있습니다. 설계가 엉켜있을 때 이를 풀어내는 것은 중요하며, 각 부분이 분리되면 언제든 다시 조합할 수 있는 유연성을 제공합니다.

```haskell
-- Haskell 예시
add :: Int -> Int -> Int
add x y = x + y

-- 명시적인 입력과 출력으로 단순화된 함수
```

위 예시처럼 함수의 입력과 출력이 명시적으로 정의되면, 코드의 의도와 동작을 쉽게 이해할 수 있습니다. 이는 복잡한 상호작용을 단일한 기능으로 분리하여 개념을 구성하기 쉽게 합니다.

## 불변성의 중요성: 읽기와 쓰기 분리

모든 동작을 불변화할 수 있는지 고민하는 것은 함수형 프로그래밍의 중요한 특징입니다. 이때 동작을 크게 '읽기', '쓰기', 또는 '둘 다'로 나누어 불변성을 유지합니다. 불변성을 유지하기 위해 흔히 사용하는 전략 중 하나가 "Copy on Write"입니다.

### Copy on Write 전략

1. **복사본 만들기**
2. **복사본 변경하기** (필요한 만큼 수정)
3. **복사본 리턴하기**

이 전략은 불변의 데이터 구조를 유지하면서 변경을 처리합니다. 이 과정에서 메모리를 더 많이 사용하고 성능이 느려질 수 있지만, 현대의 대용량 시스템에서 이러한 차이는 대부분 감지되지 않습니다.

```kotlin
// Kotlin 예시
val originalList = listOf(1, 2, 3)
val newList = originalList.toMutableList().apply { add(4) }
// originalList는 변경되지 않음

-- Haskell 예시
originalList :: [Int]
originalList = [1, 2, 3]

newList :: [Int]
newList = originalList ++ [4]
-- originalList는 변경되지 않음
```

위와 같이 Kotlin에서 불변 리스트를 가변 리스트로 변환한 후 수정하면, 원본 데이터는 여전히 불변으로 유지됩니다. 이는 구조적 공유를 가능하게 하여 효율적인 메모리 사용을 돕습니다.

## 최적화 논란과 구조적 공유

불변 데이터 구조를 사용하면 느려질 수 있다는 우려가 있습니다. 하지만 대부분의 함수형 언어는 이러한 부분을 빠르게 최적화할 수 있는 구현체로 제공됩니다. 예를 들어, 배열의 복사도 참조만 복사하는 얕은 복사를 사용하여 메모리 효율성을 높입니다. 이는 \*\*"구조적 공유"\*\*라고 불리며, 메모리 참조만 복사하기 때문에 큰 성능 저하 없이 불변성을 유지할 수 있습니다.

Kotlin에서는 `val` (value라는 뜻으로 읽기 전용) 속성으로 불변을 보장하지만, 얕은 복사를 사용할 때도 객체 구조가 변경되지 않도록 주의해야 합니다. 불변성을 유지하기 위해서는 중첩된 모든 데이터 구조도 변경되지 않아야 합니다.

## 신뢰할 수 없는 코드와 방어적 복사

신뢰할 수 없는 코드에서 불변성을 지키기 위해 "방어적 복사"가 필요할 때가 있습니다. 방어적 복사는 깊은 복사를 통해 원본 데이터를 보호하며, 다음 두 가지 규칙을 따릅니다:

- **규칙 1: 안전한 코드에서 나갈 때 복사**
  - 불변 데이터를 깊게 복사하여 신뢰할 수 없는 코드로 전달합니다.
- **규칙 2: 안전한 코드로 들어올 때 복사**
  - 변경 가능한 데이터를 깊게 복사한 후 안전한 코드에서 사용합니다.

이러한 방어적 복사는 데이터가 외부로 나가는 순간부터 보호해 줍니다. 예를 들어, Erlang이나 Elixir에서는 프로세스 간의 메시지 전달 시 데이터가 항상 복사되어 고가용성을 보장합니다.

## Copy on Write vs 방어적 복사

두 기법 모두 불변성을 유지하기 위해 사용됩니다. 하지만 ***깊은 복사(방어적 복사)는 더 많은 메모리와 연산을 필요로 하기 때문에 상황에 따라 적절하게 사용***해야 합니다. Copy on Write는 변경이 빈번하지 않은 경우에 적합하며, 방어적 복사는 외부에서 데이터의 안전성이 위협받을 수 있을 때 사용됩니다.

## 결론: 불변성과 함수형 프로그래밍

함수형 프로그래밍에서는 불변성을 유지하며 데이터와 동작을 단순하게 만드는 것이 핵심입니다. 암묵적인 입력과 출력을 명시적으로 바꾸고, 데이터를 불변으로 유지하려는 노력은 코드의 신뢰성과 유지 보수성을 높여줍니다. 현대 시스템에서는 불변성으로 인한 성능 저하가 크게 문제되지 않기 때문에, 이러한 설계를 고려해 볼 가치가 있습니다.

