# Functor, Applicative Functor, Monad

## 컨테이너 타입이란?

- `M<T>` 형식에서 M 타입을 의미함 Java의 `Optional`, js/ts의 `Array`, `Promise`가 예시
- 이러한 타입들은 각각 어떠한 맥락을 포함하고 있음

e.g. `Optional`은 `값이 존재할수도 아닐수도 있음`을 의미, `Array`는 `값이 n개있음`을 의미

## 정의

Functor, Applicative Functor, Monad는 각각 특정 연산을 지원하는 컨테이너 타입을 의미한다.

- Functor : `fmap` 연산을 지원하는 `컨테이너 타입`
- Applicative Functor : `apply` 연산을 지원하는 `Functor`
- Monad : `bind` 연산을 지원하는 `Applicative Functor`

## 목적

일반적으로 우리가 작성하는 코드는 어떤 맥락을 담고 있다.

- e.g. 값 `a`가 있을 수도 있고 없을 수도 있다.

이때 우리는 주요 관심사 함수 `f`를 실행하기 위해 특정 `사전 조건의 충족`을 확인해야 한다.

- 값 `a`가 존재하는 경우, `f(a)` 실행

이러한 맥락에 대한 제어 흐름을 추상화하여 맥락을 제어하는 코드와 주요 관심사 코드를 분리하고, 일관성있는 맥락 제어를 통해서 프로그램의 안전성을 높인다.

결론적으로, 주요 관심사 코드에 더욱 집중하게 만든다.

e.g.

- `Optional.map(f)`에서 `f`는 실제로 값이 존재하는지 아닌지에 대해 고려하지 않음
- `Array.map(f)`에서 `f`는 실제로 값이 몇 개인지는 고려하지 않음
- `Promise.then(f)`에서 `f`는 실제로 값이 언제 resolve되는지 고려하지 않음

## `<$>` (fmap)

```hs
class Functor f where
  fmap :: (a -> b) -> f a -> f b

-- (a -> b) <$> f a == f b
```

- `a -> b` 함수를 컨테이너 타입 `f` 안에서 안전하게 처리할 수 있도록 함
- haskell에서는 중위 연산자 `<$>`로 표현 가능
- haskell에서는 함수도 Functor임, 따라서 `<$>` 연산을 지원
- 현대에는 `map`으로 많이 표현

```haskell
(+1) <$> Just 1 -- Just 2
(+1) <$> Nothing -- Nothing
```

## `<*>` (apply)

- `<$>` 연산에 사용된 함수 `f`가 다항 연산자인 경우, `m g`와 같이 컨테이너 타입안에 함수가 들어감
- `apply` 연산은 맥락 안에서 함수에 인자를 전달하여 연산하기 위해 사용
- haskell에서는 중위 연산자 `<*>`로 표현 가능
- `<*>` 연산은 컨텍스트 안에서 n 항의 함수를 처리하기 위해 사용
- 현대에는 `ap`으로 많이 표현

```hs
class Functor f => Applicative f where
    pure :: a -> f a -- 단순한 리프팅 작업
    (<*>) :: f (a -> b) -> f a -> f b

-- f (a -> b) <$> f a == f b
```

### example

- fn a b c에서 a, b, c가 서로 `독립적`이며 같은 유형의 컨테이너 타입 안에 있을 때 `<*>`으로 처리한다.

```hs
fn :: Int -> Int -> Int -> Int
fn a b c = a + b + c

-- (Int -> Int -> Int -> Int) <$> Maybe Int <*> Maybe Int <*> Maybe Int
fn <$> Just 1 <*> Just 2 <*> Just 3
-- Just 6

-- Maybe (Int -> Int -> Int)
fn <$> Just 1
 -- Just fn 1

-- Maybe (Int -> Int)
Just (fn 1) <*> Just 2
 -- Just (fn 1 2)

-- Maybe Int
Just (fn 1 2) <*> Just 3
-- Just (fn 1 2 3)
-- Just 6
```

- `<*>`를 사용하지 않고 처리한 경우

```hs
(\x ->  (\f -> f <$> x) <$> (fn <$> Just 1)) Just 2
-- fn <$> Just 1 <*> Just 2
```

## `>>=` (bind)

- 하스켈 로고의 형태와 동일 (하스켈의 핵심?)
- haskell에서는 중위 연산자 `>>=`로 표현 가능
- 맥락 안에서 순차적인 연산에 사용 (의식의 흐름과 동일)
- 현대에는 `flatMap`으로 많이 표현

```hs
class Applicative m => Monad m where
    return :: a -> m a -- 단순 리프팅
    (>>=) :: m a -> (a -> m b) -> m b  -- bind

-- f a >>= (a -> f b) = f b
```

### example

```hs
add :: Int -> Int -> Maybe Int
add b a = (+b) <$> Just a


Just 0 >>= add 1 >>= add 2 >>= add 3 >>= add 4
-- Just (0 + 1 + 2 + 3 + 4)
```

### 사용 목적 및 예시

- 맥락(사전 조건)과 무관한 함수를 특정 맥락 내에서 자연스럽게 실행할 수 있도록 함
- (+1) 함수는 값이 존재하는지, 아닌지 상황에 대한 코드가 존재x

## 한계점

- 여러 컨테이너 타입을 조합하는 경우 코드가 복잡해질 수 있음
- 해당 컨테이너 타입에 대한 이해가 없으면 맥락을 이해하기가 더 어려움
  - 코드 관계자가 모두 알아야 함
- 과도한 추상화로 디버깅이 오히려 어렵게 느껴질 수 있음

## 사용 사례 in Ts

```ts
export type Maybe<T> = Just<T> | Nothing;
export type Either<L, R> = Left<L> | Right<R>;
```

```ts
declare const getUser: (input: { user_id: string }) => Promise<Either<"USER_NOT_FOUND", User>>;
declare const getProduct: (input: { product_id: string }) => Promise<Either<"PRODUCT_NOT_FOUND", Product>>;
declare const mergeOrder: (customer: User) => (product: Product) => (input: { amount: number }) => Order;
interface CreateOrderInput {
  user_id: string;
  product_id: string;
  amount: number;
}
type CreateOrderOutput = Either<"USER_NOT_FOUND" | "PRODUCT_NOT_FOUND", Order>;
const createOrder = async (input: CreateOrderInput): Promise<CreateOrderOutput> =>
  pipe(
    input,
    getUser,
    (e) => Either.map(mergeOrder)(e), // Either<"USER_NOT_FOUND", (product:Product) => Order>

    // user가 존재하는 경우에만 getProduct를 실행
    Either.flatMapAsync(async (f) => Either.map(f)(await getProduct(input))), // Either<"USER_NOT_FOUND"|"PRODUCT_NOT_FOUND", Order>

    // 만약 user 유무와 상관없이 getProduct를 호출한다면 아래 식
    // Either.ap,
    // async (ap) => ap(await getProduct(input)),

    Either.map((f) => f(input))
  );
```
