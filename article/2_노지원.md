# 하스켈에서 변수 선언 키워드

## let

표현식에서 값을 바인딩할 때 사용한다. (지역 변수 선언용)

## in

`let`으로 선언한 변수의 유효 범위를 지정하는 키워드

x는 `x + 3` 식에서만 사용할 수 있다.

```hs
let x = 5 in x + 3
```

## where

- 함수의 보조 함수나 지역 변수를 선언할 때 사용
- 함수의 본체 외부에 정의할 때 사용

```hs
fullDeck :: Deck
fullDeck = [Card r s | r <- ranks, s <- suits]
  where
    suits = [Hearts, Diamonds, Clubs, Spades]
    ranks = [Numeric n | n <- [2 .. 10]] ++ [Jack, Queen, King, Ace]
```

## case

- 패턴매칭을 할 때 사용한다. (switch 문 키워드와 유사)

```hs
shuffleDeck :: Deck -> IO Deck
shuffleDeck [] = return [] -- 빈 리스트인 경우
shuffleDeck [card] = return [card] -- 한 장의 카드만 남은 경우
shuffleDeck deck = do
  index <- randomRIO (0, length deck - 1)
  let (left, right) = splitAt index deck
  case right of
    [] -> return left
    (card : rest) -> do
      shuffled <- shuffleDeck (left ++ rest)
      return (card : shuffled)
```

## do

- IO 작업이나 순서가 중요한 작업을 실행할 때 사용
- 주로 모나드와 함께 사용
- 일반적인 언어에서 여러줄에 걸쳐서 연산코드를 작성하는 것과 유사

## data and type

- 구조체 및 타입을 선언하는 키워드
- data 구조체를 union 으로 선언할 수 있음

```hs
data Suit = Hearts | Diamonds | Clubs | Spades deriving (Show, Eq)

data Rank = Numeric Int | Jack | Queen | King | Ace deriving (Show, Eq)

data Card = Card {rank :: Rank, suit :: Suit} deriving (Show, Eq)

type Deck = [Card]

type Hand = [Card]
```

- deriving은 일종의 상속 키워드
- Show(출력 관련), Eq(비교 연산 관련) 기능을 상속한다.

## newtype

- newtype은 기존 타입을 기반으로 새로운 타입을 정의하는 데 사용하는 키워드
- newtype으로 정의된 타입은 단지 새로운 이름을 가진 타입일 뿐이며, 성능 상의 오버헤드가 거의 없습니다. newtype은 주로 타입 안전성을 강화하거나 가독성을 높이기 위해 사용됩니다.

## instance

- 타입 클래스를 정의하는 키워드
- 타입들이 특정 연산을 구현하도록 요구하는 일종의 인터페이스 역할

```hs
-- 1. 타입 클래스 정의
class Show a where
  show :: a -> String

-- 2. 타입 인스턴스 정의
instance Show Int where
  show x = "정수: " ++ show x

instance Show Bool where
  show True = "참"
  show False = "거짓"

-- 3. 사용 예
main :: IO ()
main = do
  print (show 42)       -- "정수: 42"
  print (show True)     -- "참"
  print (show False)    -- "거짓"
```

## module

- 모듈을 정의하는 키워드, 각 모듈은 분리된 네임스페이스를 갖는다.

```hs
module MyModule where
  -- 모듈 내용
```

## import

- 다른 모듈을 불러올 때 사용

```hs
import System.Random (randomRIO)
```

# IO Monad

입출력을 비롯한 사이드 이팩트가 발생하는 작업을 정의할 때 사용되는 모나드

아래의 시그니처는 부수효과를 포함하여 Deck 반환하는 함수 시그니처다.

```hs
newDeck :: IO Deck
```

IO 모나드의 시그니처는 다른 모나드 특이하다. 그 이유는 위 시그니처에서 IO Deck이 Deck 자체를 의미하지 않고 Deck을 반환하는 `행동`을 의미하기 때문이다. 이렇게 IO 모나드는 side effect가 발생하는 계산을 `지연`시킨다.

`newDeck`은 순수함수가 아니다. 따라서 실행할 때마다 다른 값을 갖는다.
예를 들어, 랜덤으로 섞인 카드 리스트를 반환한다. 아래는 덱을 생성하는 예시코드

```hs
gameLoop :: IO ()
gameLoop = do
  deck <- newDeck
  let (playerHand, deck') = drawCards 2 deck
      (dealerHand, deck'') = drawCards 2 deck'
  putStrLn "Starting a new round..."
  playRound playerHand dealerHand deck''
```

# 앞으로의 미션 계획

- 아래의 키워드에 대해 조사하는 것을 공통 과제로 할 것
- 정리 내용에는 정의, 성질, 관계, 사용되는 맥락, 예시를 포함할 것

- 3주차 Functor, Applicative (functor), Moand
- 4주차 ADT, Free Monad 패턴, 스마트 생성자, 인터프리터
- 5주차 Tagless Final 패턴 (현대에 Free Monad보다 더 선호되는 방식)
