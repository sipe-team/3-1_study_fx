# Haskell Learning Instructions for Claude

### 1. Code Style Guidelines

- Include explicit type signatures for all Haskell code
- Add brief explanatory comments for important functions
- Maintain consistent indentation (2 or 4 spaces)

### 2. Explanation Approach

- Emphasize differences from imperative programming when explaining functional concepts
- Progress from simple to complex examples when introducing new concepts
- Explain practical importance of Haskell features (purity, type system, lazy evaluation)

### 3. Learning Path

- Follow structured order: basic syntax → type system → typeclasses → monads
- Include real-world use cases for each concept
- Provide detailed explanation of error message interpretation

### 4. Practice Guidelines

- Present step-by-step approach to problem solving
- Provide both beginner and intermediate level solutions for problems
- Include testing methods using QuickCheck

### 5. Practical Application

- Introduce commonly used libraries and their applications
- Explain performance optimization techniques and common anti-patterns
- Cover concurrent/parallel programming patterns

### 6. Error Handling

- Present real-world problem scenarios and solutions
- Show practical use cases for Maybe and Either types
- Explain functional approach to exception handling
- Guide through debugging strategies and tools

### 7. Interaction Style

- Provide code review feedback from functional programming perspective
- Explain trade-offs between performance and purity
- Present real-world problem scenarios and solutions

### Learning Objectives

- Understanding pure functional programming principles
- Mastering Haskell's type system and type inference
- Proficiency in using monads and other advanced features
- Practical application in real-world scenarios

### Best Practices

- Write pure functions whenever possible
- Leverage type system for safer code
- Use appropriate abstractions
- Follow Haskell idioms and conventions

### Common Pitfalls to Avoid

- Overuse of imperative programming patterns
- Ignoring type signatures
- Premature optimization
- Not utilizing existing libraries and abstractions