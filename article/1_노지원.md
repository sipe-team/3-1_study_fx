# Why FP?

코드를 작성할 때 항상 가지고 있는 관심사가 있지 않나요?

제 관심사는 신뢰도가 높고 예측가능한 코드를 작성하는 것입니다. 그리고 함수형 패러다임의 목표이기도 합니다.

다른 표현으로 함수형 프로그래밍의 핵심을 설명하자면 `수학적 정확성과 예측 가능한 계산 모델을 통해 오류를 줄이고, 프로그램의 안정성과 가독성을 높이는 것`입니다.

이러한 특징은 복잡한 시스템을 구축하거나 동시성 작업을 수행할 때 큰 이점을 제공하고 생산성을 향상시킬 수 있습니다.

# What FP?

함수형 프로그래밍(FP)은 이름처럼 `함수`를 주요 구성 요소로 하여 프로그램을 설계하는 방식으로 선언형 패러다임에 속합니다. 프로그래밍 패러다임은 크게 `명령형`과 `선언형`으로 구분합니다.

## 명령형 패러다임(Imperative Paradigm)

프로그램의 실행 순서와 상태 변화를 명시적으로 지시. 즉, 프로그램이 `어떻게` 작업을 수행할지에 초점을 둔다.

## 선언형 패러다임(Declarative Paradigm)

프로그램이 `무엇을` 수행할 것인지에 초점을 두고 구체적인 실행 방법 및 세부사항은 숨긴다.

- 추상화 수준이 매우 높음
- 코드가 목적 중심이므로 읽기가 쉬움

# How FP?

FP를 적용하기 위한 기초적인 방법입니다.

- 큰 문제를 최대한 작은 문제로 쪼개자.
  - 작은 문제에 대한 함수는 재사용성이 높을 것이다.
- 함수를 `순수 함수`로 만들자.
  - 부작용 함수를 최대한 분리하는 것이 재사용성 및 테스트, 디버깅에 유리할 것이다.
- 데이터의 `불변성`을 유지하자.
  - 동작 예측이 쉽고 순수 함수가 실제로 부작용이 없게 하기 위해서 필수적인 요소다.
- `고차 함수`를 적극 활용하자.
  - 작은 문제를 연결해 큰 문제를 해결하자.
  - 이를 위해서는 언어적인 수준에서 함수를 `일급 객체`로 취급해야 한다.

# 왜 하스켈을 배워야할까?

하스켈은 `순수 함수형 프로그래밍 언어의 원형을 정의하는 것`을 목표로 설계되었습니다.

즉, 하스켈 언어의 특징을 공부하면 자연스럽게 FP를 알 수 있고, FP의 원형을 이해하고 적용할 수 있습니다.

---

# 1주차 기간동안 얻어낸 키워드

- Point-Free Style, ADT, HKT

## Point-Free Style (PFS)

Point-Free Style은 함수를 정의할 때, 함수의 매개변수를 명시하지 않고 함수의 조합이나 합성을 통해 로직을 표현합니다.

### 예시

```haskell
processStrings :: [String] -> [String]
processStrings strings = filter (\s -> length s >= 5) (sort (map length strings))

```

```haskell
processStrings :: [String] -> [String]
processStrings = filter (\s -> length s >= 5) . sort . map length
```

### 목적

- 코드 간결화

  PFS는 불필요한 중간 변수나 명시적인 인자를 생략하여 코드를 짧고 간결하게 만들어줍니다.

- 함수 조합에 초점

  함수 정의를 할 때 입력 파라미터 대신 함수 조합에 집중함으로써 코드의 의미와 함수 간의 연결을 더 명확히 표현할 수 있습니다.

- 높은 추상화 수준 유지

  파라미터를 드러내지 않으므로 함수의 내부 동작보다는 함수가 어떤 처리를 수행하는지에 더 집중하게 되어, 함수형 코드의 추상화 수준을 높여줍니다.

### 특징

- 파라미터 생략

  함수를 정의할 때 파라미터를 생략하고, 함수 조합만으로 표현합니다.

- 함수 조합 연산자 활용

  PFS에서는 compose (∘)나 andThen (>>)와 같은 함수 조합 연산자를 사용하여 여러 함수를 하나의 새로운 함수로 결합합니다.

- 가독성 향상

  코드를 읽을 때 데이터의 흐름이 명확하게 드러나기 때문에, 특히 간단한 연산에서는 가독성이 향상될 수 있습니다. 하지만 과도하게 사용하면 오히려 이해하기 어려워질 수 있으므로 적절히 사용하는 것이 중요합니다.

## Algebraic Data Type (ADT)

ADT는 두 가지 주요 구성 요소(합집합과 곱집합)를 통해 사용자 정의 데이터 타입을 생성하는 방법입니다. 이는 서로 다른 데이터 타입을 조합하여 새로운 타입을 만들 수 있도록 합니다.

### Sum Type

합집합 타입은 여러 타입 중 하나의 값을 가질 수 있는 타입입니다. 즉, 다양한 형태의 값을 포함할 수 있습니다.

- TS의 유니온 타입 혹은 enum과 동일

```haskell
data Shape = Circle Float | Rectangle Float Float
```

합집합 타입은 패턴 매칭을 통해 각 타입에 대해 구체적인 동작을 정의할 수 있습니다.

```haskell
area :: Shape -> Float
area (Circle r) = pi * r * r
area (Rectangle w h) = w * h
```

### Product Type

곱집합 타입은 여러 값을 하나의 값으로 묶는 타입입니다. 즉, 여러 필드를 가진 `구조체`를 만드는 것입니다.

```haskell
data Point = Point Float Float
```

### 목적

- 명확하고 안전한 데이터 모델링

  ADT는 데이터의 가능한 형태와 상태를 명확하게 정의할 수 있도록 하여, 복잡한 데이터 구조나 상태를 보다 직관적이고 안전하게 다룰 수 있게 합니다.

- 타입 안전성

  ADT를 통해 데이터의 가능한 모든 경우를 타입 시스템에서 표현할 수 있으므로, 런타임 오류를 줄이고 컴파일 시에 오류를 잡을 수 있는 타입 안전성을 제공합니다.

- 패턴 매칭 지원

  ADT로 정의된 데이터 타입은 패턴 매칭을 통해 각 경우에 따라 처리 로직을 분기할 수 있습니다. 이는 데이터 구조의 각 상태나 케이스를 다룰 때 유연성과 가독성을 높여줍니다.

- 유지 보수와 확장성 향상

  ADT는 데이터의 가능한 모든 케이스를 한 곳에서 정의하기 때문에 새로운 상태나 케이스를 추가할 때도 명확하고 일관되게 유지할 수 있습니다.

### 특징

- Sum 타입 (합 타입, Coproduct Type)

  여러 가지 서로 다른 케이스 중 하나의 상태만 가질 수 있는 타입입니다.
  `Either`, `Option`, `Result` 같은 타입이 대표적입니다.

- Product 타입 (곱 타입, Tuple 또는 Record Type)

  여러 필드를 묶어서 하나의 복합 타입을 만듭니다. 예를 들어, 좌표 (x, y)로 구성된 `Point` 타입이나, 이름과 나이를 가지는 `Person` 타입이 예입니다.

- 명확한 타입 표현

  ADT는 데이터의 가능한 상태를 명확하게 정의하여 의도를 분명히 드러내므로 코드가 더 읽기 쉽고 유지보수가 용이합니다.

  예를 들어 `Option` 타입의 `Some`과 `None`은 값이 있을 수도, 없을 수도 있는 상태를 명확히 나타냅니다.

## Higher-Kinded Types (HKT)

HKT는 타입 생성자(Type Constructor)를 다루는 타입입니다. 즉, 다른 타입 생성자를 인자로 받을 수 있는 타입입니다. 이를 통해 보다 일반화된 형태로 타입을 정의하고 사용할 수 있습니다.

### 예시

- ts 언어는 HKT를 지원하지 않아서 완전히 표현할 수 없습니다. 아래의 형태는 실제로 동작하지 않지만 예시로 작성했습니다.

```ts
interface Functor<T> {
  fmap: <B>(f: (a: T) => B, input: M<T>, this: M<T>) => M<B>;
}

interface Maybe<number> {
  fmap: <T>(f: (a: number) => T, this: Maybe<number>) => Maybe<T>;
}
```

```haskell
-- HKT를 사용하는 예시: Functor 타입 클래스
class Functor f where
    fmap :: (a -> b) -> f a -> f b
```

- 여기서 f는 타입 생성자입니다. f는 어떤 타입을 감싸는 구조체로, f a는 a 타입을 포함하는 f 타입을 의미합니다. Functor는 타입 생성자가 f일 때 사용할 수 있는 일반적인 연산인 fmap을 정의합니다.

```haskell
-- HKT를 사용하는 예시: 여러 타입을 가지는 Functor
data Maybe a = Nothing | Just a
data List a = Nil | Cons a (List a)

instance Functor Maybe where
    fmap _ Nothing = Nothing
    fmap f (Just x) = Just (f x)

instance Functor List where
    fmap _ Nil = Nil
    fmap f (Cons x xs) = Cons (f x) (fmap f xs)

```

### 목적

- 추상화의 확장

  HKT는 코드의 추상화를 높여주어, 특정 타입에 국한되지 않고 다양한 데이터 타입에 대해 동작하는 일반적인 연산을 정의할 수 있게 합니다. 예를 들어, List, Option, Future 같은 컨테이너 타입을 동일한 방식으로 처리할 수 있게 합니다.

- 모나드와 같은 타입 클래스 정의

  HKT를 사용하면 Monad, Functor 같은 타입 클래스 인터페이스를 추상화할 수 있어, 모든 모나드가 공통으로 구현해야 하는 메서드를 정의할 수 있습니다. 이는 flatMap, map과 같은 고차 함수가 여러 컨텍스트에 대해 일관되게 동작하도록 지원합니다.

- 재사용성

  HKT를 사용하면 코드의 재사용성을 높이고 중복을 줄일 수 있습니다. 다양한 컨테이너 타입을 동일한 함수로 처리할 수 있으므로, 한 번의 구현으로 여러 타입에서 동일한 로직을 공유할 수 있습니다.

### 특징

- 타입 레벨의 고차 함수

  HKT는 타입을 다루는 고차 함수의 개념으로, 다른 타입을 인수로 받아 새로운 타입을 생성합니다.

- 다양한 데이터 컨텍스트 지원

  Option, List, Either 등과 같은 여러 컨테이너 타입을 동일한 인터페이스로 다룰 수 있게 하여 일관된 API를 제공할 수 있습니다.

- 타입 추론

  HKT가 적용된 언어(예: Scala, Haskell)에서는, 타입 시스템이 HKT를 활용해 제네릭 컨텍스트에 따라 타입을 추론하므로 코드 작성 시 유연성과 안정성을 높입니다.
